---
layout: post
date: 2024-08-12
title: "[Database] 트위터에서 Primary key를 생성하는 방법"
tags: [Dabatabse, Twitter, Architecture, ]
categories: [Database, ]
---


데이터베이스 샤딩 시 어떤 기준으로 샤딩을 할 것인지? 


user_id로 샤딩을 했을 경우 한 서버에 사용자의 트윗 정보가 모두 저장되어있기 때문에 조회하기 편하다. 하지만 몇가지의 문제가 있다. 

- 특정 사용자가 인기를 끌게 되면, 해당 사용자의 데이터를 보유한 서버에 많은 요청이 몰려 과부하가 발생한다.
- 일부 사용자는 다른 사용자에 비해 훨씬 더 많은 트윗이나 팔로워를 갖게 되어 서버 간 데이터가 고르게 분배되지 않는다. 이런경우 샤드을 효율적으로 쓸 수가 없다.
- 특성 샤드의 공간을 늘려야 할 경우 재배치를 해야하기 때문에 리소스가 많이 발생한다.

특정 사용자의 정보를 캐시에 저장하는 것도 하나의 방법이지만 여전히 샤딩을 효율적으로 사용하는 방법이 아니다. user_id 대신 사용할 수 있는 방법은 어떤게 있을까?


트윗 ID를 에포크시간 + auto-increment 방식으로 구현 시 시간 기반으로 샤딩이 생성되기 때문에 여러 샤드에 고르게 분배가 될 수가 있다. 시간과 auto-increment를 함께 사용할 경우 트윗이 생성된 순서대로 정렬되기 때문에 트위터와 같은 타임라인을 생성할때 효율적이다.  이전에 포스팅했던 인스타그램과 거의 유사한 방식이다. 인스타그램은 Shard ID도 함께 추가했다는게 다른 점이다.


트위터에서 에포크시간으로 키 생성 시 길이는 얼마나 되야할까?


50년동안 트위터 데이터를 저장해야한다고 생각했을 때 50년을 에포크 시간의 단위인 초로 바꾸면 아래와 같다. 



{% raw %}
```text
(24*60*60) * 365 * 50 = 1,576,800,000sec
```
{% endraw %}



에포크 시간에 따라 샤딩이 1,576,800,000개로 나눠져야 하는데 31비트(2,147,483,648)를 사용했을 때 이 숫자가 필요하다. 하지만 트위터의 사용자가 하루에 100,000,000명이라고 가정했을 때 1초당 트윗 등록 수는 약1157건이기 때문에 동시에 키 발급 요청이 이루어질 수 밖에 없다. 이러한 문제를 방지하기 위해 auto-increment를 에포크시간 뒤에 붙여서 같은 초에도 auto-increment에 따라 순서대로 등록할 수 있도록 처리할 수 있다. auto-increment의 비트는 17비트를 사용할 경우 13000개의 키 생성이 가능하기 때문에 트래픽 증가를 고려했을 때도 충분한 비트수가 될 수 있다. auto-increment는 같은 초 내에서 순서를 정하기 위해 추가한 방법이기 때문에 계속 증가시킬 필요 없이 매초당 리셋되도록 설정하면 된다.


이렇게 구성하게 될 경우 트위터의 타임라인은 시간별로 표시되기 때문에 creation_date에 인덱스를 따로 추가할 필요 없이 빠르게 데이터를 조회하고 정렬할 수 있다. 


시간에 따라 저장되기 때문에 여러 샤딩에서 동일한 user_id기준으로 데이터를 병합해야하는 단점이 있지만 user_id 인덱스를 추가한다면 문제가 없을 것이다. 


#### **트위터에서의 샤딩 구현 방안:**

1. **트윗 ID 설계**:
	- 트윗 ID는 **시간(Epoch Time) + auto-increment** 방식으로 구성한다.
	- 예를 들어, 에포크 시간(1970년 1월 1일 기준 초 단위)과 auto-increment 값을 결합하여 트윗 ID를 생성한다.
	- 각 트윗 ID는 고유하며, 생성된 시점에 따라 자연스럽게 정렬된다.
2. **샤드 선택 알고리즘**:
	- 트윗이 생성될 때, 트윗 ID에 기반하여 샤드를 선택하는데 시간에 따른 데이터 분산을 위해 `MOD(트윗 ID % 샤드 수)`와 같은 방법을 사용하여 트윗이 저장될 샤드를 결정할 수 있다.
	- 이를 통해 시간에 따라 트윗이 고르게 샤드에 분산되며, 특정 샤드에 데이터가 몰리지 않도록 한다.
3. **타임라인 생성**:
	- 사용자가 타임라인을 조회할 때, 최근 생성된 트윗을 시간 순서대로 빠르게 조회할 수 있도록 샤드에서 데이터를 병렬로 조회한다.
	- 각 샤드에서 조회된 데이터를 애플리케이션 서버에서 병합하고, 최종 타임라인을 구성하여 사용자에게 제공한다.
4. **캐싱 전략**:
	- 인기 있는 트윗이나 특정 시간대에 생성된 트윗은 캐싱하여, 반복 조회 시 데이터베이스에 부담을 줄이고 응답 시간을 단축할 수 있다.
