---
layout: post
date: 2024-08-13
title: "[SystemDesign-Typeahead Suggestion] Algorithm"
tags: [SystemDesign, Architecture, Typeahead Suggestion, ]
categories: [SystemDesign, Problems, Typeahead Suggestion, ]
---


### 1. **MapReduce를 이용한 검색어 추천 시스템 구축**


MapReduce는 대규모 데이터를 처리하는 데 적합한 프레임워크로, 검색어 추천 시스템에서도 활용할 수 있다. 이 방법은 주로 배치 처리(batch processing)를 통해 주기적으로 검색어 추천 데이터를 갱신하며, 하위 노드에서 상위 노드로 데이터를 합산해 올라가는 방식으로 작동한다.


#### **단계 1: 데이터 수집**

- **로그 수집**: 사용자가 검색한 검색어와 그 빈도수를 로그 파일에 기록한다. 이 로그는 일정 기간 동안(예: 하루, 한 주 등) 축적한다.

#### **단계 2: Map 단계**

- **입력 데이터**: 로그 파일에서 검색어 데이터를 읽어들여, 각 검색어를 키(key)로, 발생 횟수를 값(value)으로 매핑한다.

	예시:


	
{% raw %}
```text
	"cat" -> 1
	"cap" -> 1
	"cat" -> 1
```
{% endraw %}


- **매핑**: 동일한 검색어를 같은 키로 묶어서 각 검색어의 발생 횟수를 세어준다.

	예시:


	
{% raw %}
```text
	"cat" -> 1
	"cat" -> 1
	"cap" -> 1
```
{% endraw %}



#### **단계 3: Reduce 단계**

- **키별 합산**: Map 단계에서 생성된 키-값 쌍을 수집하여 동일한 키(검색어)를 가진 값들을 모두 합산해, 각 검색어의 총 빈도수를 계산한다.
	- **하위 노드에서 상위 노드로 데이터 합산**: 이 단계에서 각 노드는 자신의 하위 노드들로부터 데이터를 받아 상위 노드로 빈도수를 전달해준다. 예를 들어, 'T' 노드는 'A' 노드로 자신의 빈도수를 합산해 전달하고, 'A' 노드는 'C' 노드로 데이터를 전달해 전체 트리에서 각 검색어의 빈도수를 계산한다.

	예시:


	
{% raw %}
```text
	"cat" -> 2
	"cap" -> 1
```
{% endraw %}


- **결과 출력**: 빈도수가 계산된 검색어 목록을 출력하여, 이 데이터를 기반으로 검색어 추천을 생성한다.

#### **단계 4: 검색어 추천**

- **상위 N개 검색어 선정**: Reduce 단계에서 얻은 빈도수 데이터를 이용해, 가장 빈도수가 높은 상위 N개의 검색어를 추천 리스트로 생성한다.
- **결과 활용**: 이 추천 리스트를 주기적으로 갱신하여 사용자에게 최신 검색어 추천을 제공한다.

#### **장점과 단점**

- **장점**:
	- 대규모 데이터 처리에 적합하다.
	- 분산 처리로 인해 확장성이 뛰어나다.
	- 하위 노드에서 상위 노드로 데이터를 합산하는 방식으로 효율적인 계산이 가능하다.
- **단점**:
	- 실시간 처리에 적합하지 않아, 주기적인 배치 처리에 의존한다.
	- 실시간으로 사용자의 입력에 반응하기 어렵다.

#### 2. **Min-Heap을 이용한 검색어 추천 시스템 구축**


Min-Heap은 메모리 내에서 상위 N개의 검색어를 유지하고, 실시간으로 추천 검색어를 제공하는 데 유리한 데이터 구조야. 실시간으로 빈도수가 높은 검색어를 관리하면서 추천할 수 있다.


#### **단계 1: Trie와 Min-Heap 초기화**

- **Trie 생성**: 각 문자를 노드로 하는 Trie를 생성해, 검색어를 삽입할 때마다 경로를 따라 노드를 생성한다.
- **Min-Heap 초기화**: 각 Trie 노드에 대해 최대 N개의 검색어를 저장할 수 있는 Min-Heap을 생성한다.

#### **단계 2: 검색어 삽입 및 빈도수 업데이트**

- **검색어 삽입**: 새로운 검색어가 입력되면, 해당 검색어를 Trie에 삽입한다. 예를 들어, "cat"을 삽입하면 `C -> A -> T` 경로를 따라 노드를 생성하거나, 이미 있는 노드를 이용해 검색어를 삽입한다.
- **빈도수 업데이트**: 검색어가 삽입될 때마다 해당 Trie 경로의 각 노드에서 Min-Heap에 검색어를 추가해준다.
	- **Min-Heap 유지**: Min-Heap의 크기가 N을 초과할 경우, 가장 작은 빈도수를 가진 검색어를 제거하여 크기를 유지한다.

#### **단계 3: 검색어 추천**

- **실시간 추천**: 사용자가 입력하는 접두사(prefix)에 대해 Trie를 탐색해 해당 노드에 도달하면, 해당 노드의 Min-Heap에서 상위 N개의 검색어를 추천 리스트로 제공한다.

	예시: 사용자가 "ca"를 입력하면, Trie에서 `C -> A` 노드를 탐색하고, `A` 노드의 Min-Heap에서 "cat", "cap" 등을 추천해준다.


#### **장점과 단점**

- **장점**:
	- 실시간 검색어 추천에 적합하다.
	- 메모리 내에서 상위 검색어를 빠르게 관리할 수 있다.
- **단점**:
	- 매우 큰 데이터 세트에서는 메모리 사용량이 늘어날 수 있다.
	- 각 Trie 노드에 Min-Heap을 유지해야 하므로, 구조가 복잡해질 수 있다.

#### **결론**

- **MapReduce**는 대규모 데이터를 주기적으로 처리하여 검색어 추천을 갱신하는 데 적합하며, 분산 환경에서 강력한 성능을 발휘한다. 하위 노드에서 상위 노드로 데이터를 합산하는 방식으로 작동하여 효율적인 계산이 가능하지만, 실시간 처리에는 적합하지 않다.
- **Min-Heap**을 사용한 방법은 실시간으로 검색어를 추천해야 하는 시스템에 적합하며, 사용자 입력에 빠르게 반응할 수 있다. 하지만 매우 큰 데이터 세트에서는 관리가 복잡해질 수 있다.
