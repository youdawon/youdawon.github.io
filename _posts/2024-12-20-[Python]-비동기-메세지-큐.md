---
layout: post
date: 2024-12-20
title: "[Python] 비동기 메세지 큐"
tags: [Python, ]
categories: [Python, ]
---


## 프로젝트 개요


어쩌다 보니 자바 개발자로서 파이썬 기술 첼린지에 참여하게 되었다. 이번 첼린지는 MSA(Microservices Architecture) 환경에서 비동기 메시지 큐를 설계하고 구현하는 것이 주제였다. 특히, 하나 이상의 서비스에 WebSocket을 연동해야 한다는 요구사항이 있었다. 


나는 서비스 A에서는 REST API를 통해 메시지를 수집하고 이를 메시지 큐에 저장한 뒤, 서비스 B에서 해당 메시지를 가져와 WebSocket을 이용해 클라이언트로 전달하는 방식을 선택했다. 이 구조를 통해 비동기 메시지 큐의 기본 동작과 WebSocket 통합을 효과적으로 구현할 수 있었다. 자바 개발자로서 이번 파이썬 기술 첼린지는 새로운 도전이었고 많은 것을 배울 수 있는 기회였다. 


### 설계 과정 및 기술 선택 


#### 기술 선택의 배경


나는 파이썬을 거의 모르는 상태에서 이 과제를 시작했다. 회사에서 제안한 FastAPI와 asyncio.Queue를 사용하라는 힌트를 바탕으로 기술선택을 고민했다. 

- FastAPI : 고성능 REST API 프레임워크로 비동기 작업이 많은 애플리케이션에 적합하다. 특히, Swagger UI를 자동으로 생성해 개발 생산성을 높일 수 있어 매우 유용했다.
- asyncio.Queue : 비동기 큐로 단일 프로세스에서 사용 가능하지만, 과제에서 요구한 MSA 구조에는 적합하지 않았다. 서비스 간의 독립성을 유지하려면 asyncio.Queue를 사용하는 방식은 MSA의 장점을 살리지 못한다고 생각했다.

#### MSA와 기술 적합성


MSA 구조에서는 하나의 서비스에 장애가 발생해도 다른 서비스에 영향을 주지 않아야 한다. 하지만 asyncio.Queue는 특정 서비스가 큐를 관리하는 방식으로 작동하기 때문에, 한 서비스의 장애가 다른 서비스에 영향을 미칠 수 있다. 따라서 외부 큐를 도입하기로 결정했다. 


#### Redis 리스트 선택 


Redis는 이전에 해시맵 형태로는 사용해봤지만 리스트로 사용하는 것은 처음이었다. 

- Redis 리스트의 장점 : 메세지를 큐에 저장하고, 최대 크기를 설정할 수 있어 과제 요구사항에 적합했다. 또한, 최대 크기를 설정할 수 있다는 것은 서버의 리소스에 맞게 크기를 설정할 수가 있고 그만큼 서버에 부하를 적게 줄 수 있다는 것이다.
- Redis Pub/Sub 배제 이유 : Pub/Sub은 실시간 메세지 브로커로 적합하지만, 메세지를 큐에 저장하지 않고 바로 소비한다. 이는 메세지 큐의 특성과는 맞지 않았다.
- RabbitMQ와 Kafka 배제 이유 : 두 기술은 고성능 애플리케이션에 적합하지만, 파이썬 초보로서 이 과제에서 사용하기엔 오버엔지니어링이라고 판단했다.
- brpop의 사용 이점 : brpop은 타임아웃을 설정하면 무한 대기를 하지않고 타임아웃 시간만큼 대기가 가능하다. 그렇기 때문에 큐 메세지가 없는 경우 다음 폴링이 있을 때까지 타임아웃 시간만큼 대기가 가능하여 거의 실시간처럼 데이터를 조회할 수 있다.

#### 데이터 가져오기 방식 선택 


Redis 리스트를 선택한 후, 메세지를 가져오는 방법으로 스케줄러, 폴링, 롱 폴링을 검토했다. 

- 스케줄러 배제 : 별도의 라이브러리를 사용해야 하기 때문에 제외하였다.
- 롱 폴링 배제 : 서버가 대기 상태에 머물러야 하며, 리소스 낭비 가능성이 있다고 판단했다.
- 폴링 선택 : 폴링은 특정 간격으로 데이터를 조회하는 방식으로, 구현이 간단하고 리소스 사용을 예측하기 쉬워 선택하였다.

#### 풀링 간격 설정


폴링 간격은 2초로 설정하였다. 

- 이유 : 1초는 너무 짧아 서버 부하가 많을 가능성이 있다고 판단했다. 또한, 2초의 경우 거의 실시간으로 메세지를 가져올 수 있어서 알맞는 값이라고 생각한다. 하지만 해당 값은 설정 파일에서 관리하며 성능 테스트를 통해 값을 검증하고 조정할 수 있도록 설계하였다.

#### 메세지 큐의 관리 


ltrim : 언급했던 것처럼 리스트는 최대값 관리가 가능하다. 첫번째 값엔 큐의 이름, 두번째 값은 큐의 최대 크기, 마지막 값은 자르고자 하는 큐의 크기를 설정하면 된다. 마이너스 값으로 입력된 이유는 배열의 끝부터 시작하기 때문에 마이너스값으로 입력한 것이다. FIFO를 구현하기 위해서는 늦게 추가한 값들은 남기고 먼저 들어온 값들을 삭제하는 것이 맞다. 



{% raw %}
```python
await redis_client.ltrim(self.queue_name, -4, -1)
```
{% endraw %}



### 배운 점과 개선 가능성


회고록에 쓴 내용을 바탕으로 개선 가능한 부분을 작성하면 이렇다. 

1. 더 많은 테스트 필요 : 시간이 제한된 상황에서 핵심 기능 구현에 집중하면서 테스트를 작성했다. 뿐만 아니라 엣지케이스나 유닛테스트, 통합테스트도 테스트 스크립트를 작성해서 더 완벽한 프로그램을 개발해야겠다는 생각이 들었다.
2. 에러 처리 : 현재는 3번 재요청을 할 필요가 없는 부분도 모두 재요청하게 되어있다. 케이스별로 좀 상세히 나눠서 특정 에러에 맞는 처리로직을 추가하면 좋을 것 같다.
3. Dead Letter Queue : 테스트를 하면서 웹페이지를 새로고침했을 때 websocket을 새로 연결하는 과정에서 기존 연결이 정상적으로 정리되지 않은 걸 확인했고 그로 인해 메세지 전송에 실패한 경우가 있었다. 이런 경우가 아니더라도 메세지가 정상 발송되지 않은 문제가 있을 것이다. 이를 방지하기 위해 Dead Letter Queue는 Redis 리스트로 구현하여 실패 메시지를 저장한다. 주기적으로 스케줄러를 실행하여 메시지를 재처리하며, 일정 횟수 이상 실패한 메시지는 별도 대시보드에서 확인하여 수동으로 처리하면 좋을 것 같다.
4. 메세지 필터링 최적화 : 내 프로젝트는 작은 프로젝트였기 때문에 메세지 필터링을 비지니스 로직 내부에서 처리했지만 메세지 필터링에 대해서 조사하면서 Lua 스크립트에 대해 알 수 있었다. Lua 스크립트를 이용하면 Redis 서버에서 필터링을 처리할 수 있기 때문에 클라이언트와의 네트워크 왕복을 줄이고 데이터 전송량도 감소시킬 수 있다. 다만, Lua 스크립트도 공부해서 작성해야하는데 나에게는 그럴 시간이 별로 없었기 때문에 개선을 한다면 비지니스 로직이 아닌 Redis 내부에서 Lua 스크립트를 통해 필터링을 하는 방법을 검토해볼 것이다. Redis 내부에서 필터링을 한다면 서버의 리소스 사용도 줄일 수 있는 방법이지 않나 생각한다.
5. 에러 및 응답 처리 모듈화 : 개발 시간이 별로 없는 관계로 모듈화는 하지 못하고 string을 json으로 전달하는 방식으로 간단하게 처리했지만 아무래도 이런 부분을 모듈화하는 건 기본이라고 생각하기 때문에 시간이 있다면 모듈화를 진행했을 것이다.
6. 폴링 간격 수정 : 폴링 간격을 2초로 설정 하였지만 성능테스트를 실행 했을 경우 최적의 시간을 확인할 수 있었을 것이라 생각한다.

### 문제 해결 과정 


다른 부분은 사실 그렇게까지 많은 문제를 갖진 않았지만 제일 어려웠던 부분을 뽑자면 유닛테스트였다. 전에 다니던 회사는 SI였기 때문에 코드의 품질보다 프로젝트 일정에 맞춰 개발을 끝내기 급급했다. 때문에 유닛테스트보단 통합테스트로 대체했고 이때문에 사실 나는 유닛테스트에 대한 경험도 없었고 잘 모르기도 해서 어떻게 해야할지 막막했다. 하지만 이번 기회에 유닛테스트를 작성하면서 사실 많은 것을 배웠다. 


첫번째로는 파이썬은 DI에 아주 유연한 언어라는 것이다. 자바의 경우 전달하려는 파라미터 값을 null이라도 전달하지 않으면 메소드를 사용할 수가 없다. 하지만 파이썬은 필요한 경우에만 값을 전달할 수가 있고 그 값의 이름을 메소드를 선언할 때 정확히 작성해주면 문제가 없다. 예를 들어서 처음에는 Redis URL을 설정 파일에서 직접 가져와 객체를 생성했지만, 이를 바로 적용했을 때 Redis mock테스트에서 계속 에러가 발생했다. 이는 테스트 스크립트에서 url을 테스트 용으로 바꿔치기 하는 작업이 제대로 적용되지 않아 발생한 문제였다. 그래서 더 유연한 테스트를 위해 왠만하면 모든 파라미터들을 DI로 할수 있게 로직을 수정하였다. 


두번째로는 유닛테스트는 사실 첫개발보다 유지보수를 위해 꼭 필요한 점이라는 것이다. 리팩토링이나 기능을 추가하면서 원래 잘 작동하던 코드들이 작동하지 않는 경우가 있는데 유닛테스트를 미리 작성해둔다면 개발을 마친 후 유닛테스트를 실행하면서 에러를 빠르게 발견할 수 있다. 처음에 작성하기엔 번거롭지만 한번 작성해두면 유지보수하는데 도움이 되고 더 나은 퀄리티의 코드를 작성하는데 도움을 준다고 생각한다. 


### 결론


사실 코드를 다시한번 확인하면서 실수한 부분을 찾아냈는데 생각보다 잘 만들어서 그런지 챌린지는 통과했고 이제 면접을 향해서 달려가고 있다. 솔직히 처음에는 너무 막막했지만 며칠동안 제대로 먹지못해가면서 해온 결과가 이렇게 나와서 기분이 좋긴 하다. 하지만 역시 항상 생각했던것처럼 개발에 언어는 문제가 안된다. 


난 항상 새로운 기술을 배우는데 갈망 했는데 이번기회에 여러경험을 해볼 수 있어서 너무 만족스러웠다. 사실 지금 다시 코드 리뷰를 하면서 이슈를 찾아서 걱정이 되긴 하는데 내가 그렇게 잘못 개발했다면 면접 제의는 오지 않았겠지? 자신감을 갖고 열심히 준비해야겠다는 생각이 든다.

