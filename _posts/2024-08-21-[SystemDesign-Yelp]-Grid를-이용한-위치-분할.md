---
layout: post
date: 2024-08-21
title: "[SystemDesign-Yelp] Grid를 이용한 위치 분할"
tags: [System Design, Yelp, ]
categories: [System Design, Problems, ]
---


### a. **SQL 솔루션**

- **기본 아이디어**: 데이터를 MySQL 같은 데이터베이스에 저장하고, 각 장소는 고유한 `LocationID`로 식별된다. 위도와 경도를 각각의 열에 저장하고, 이 열들에 인덱스를 만들어 빠른 검색을 수행한다.
- **검색 쿼리**: 특정 위치(X, Y)와 반경 'D' 내의 장소를 찾기 위해 다음과 같은 쿼리를 사용할 수 있다.

	
{% raw %}
```sql
	SELECT * FROM Places WHERE Latitude BETWEEN X-D AND X+D AND Longitude BETWEEN Y-D AND Y+D
```
{% endraw %}


- **문제점**:
	- 이 쿼리는 정확하지 않을 수 있다. 왜냐하면 두 지점 사이의 거리를 계산하려면 피타고라스 정리를 사용해야 하기 때문이다.
	- 또한, 두 개의 별도 인덱스를 사용하므로 각 인덱스가 반환하는 결과 리스트가 매우 길어질 수 있으며, 이 두 리스트의 교집합을 계산하는 것은 비효율적일 수 있다.
	- 'X-D'와 'X+D' 사이 또는 'Y-D'와 'Y+D' 사이에 너무 많은 위치가 있을 수 있으므로, 쿼리의 성능을 개선하려면 이 리스트들을 줄일 방법이 필요하다.

#### b. **그리드(Grid) 접근법**

- **기본 아이디어**: 지도를 작은 그리드로 나누어 각 그리드 내에 위치를 그룹화한다. 이렇게 하면 특정 위치와 반경 내의 장소를 찾기 위해 몇 개의 그리드만 검색하면 된다.
- **그리드 크기 설정**:
	- 그리드 크기는 검색하려는 거리와 동일하게 설정하는 것이 이상적이다. 그러면 주어진 위치가 포함된 그리드와 그 이웃하는 8개의 그리드만 검색하면 된다.
- **데이터베이스 구조**:
	- 각 위치에 대해 `GridID`를 저장하고, 빠른 검색을 위해 `GridID`에 인덱스를 추가할 수 있다.
	- 쿼리는 다음과 같이 작성될 수 있다:

		
{% raw %}
```sql
		SELECT * FROM Places WHERE Latitude BETWEEN X-D AND X+D AND Longitude BETWEEN Y-D AND Y+D AND GridID IN (GridID, GridID1, GridID2, ..., GridID8)
```
{% endraw %}


- **메모리 내 인덱스**:
	- 인덱스를 메모리에 유지하면 성능이 향상될 수 있다.  이 경우, 해시 테이블을 사용하여 'key'로 그리드 번호를, 'value'로 그리드 내 장소 리스트를 저장할 수 있다.
- **문제점**:
	- 장소가 균일하게 분포되지 않았기 때문에, 특정 그리드에 많은 장소가 몰릴 수 있다. 이로 인해 성능이 저하될 수 있다.
	- 그리드 크기 `D`에 따라 지구 전체가 분할되고, 각 그리드에 고유한 Grid ID가 부여된다. 이 Grid ID는 장소 데이터와 직접 연결되어 있으므로, 그리드 크기를 변경하면 모든 장소 데이터를 다시 계산하고 재분배해야 한다.
	- 기존의 Grid ID가 모두 무효화되기 때문에, 새로운 Grid ID로 데이터를 다시 매핑해야 하며, 이는 대규모 데이터베이스에 대해 매우 시간이 많이 걸리는 작업이며 메모리에 저장된 인덱스(예: 해시 테이블 등)도 다시 생성해야 한다.
	- 그리드 크기를 변경하는 동안 시스템이 일시적으로 중단되거나 성능이 크게 저하될 수 있다. 특히, 실시간 검색이 중요한 시스템에서는 이러한 변경이 큰 문제가 될 수 있다.
- **해결책**:
	- 그리드 크기를 동적으로 조정한다. 특정 그리드에 많은 장소가 모이면 해당 그리드를 더 작은 그리드로 분할한다.
