---
layout: post
date: 2024-08-24
title: "[Algorithm] Dynamic Programming 및 Leetcode 문제"
tags: [Algorithm, Dynamic Programming, ]
categories: [Algorithm, Dynamic Programming, ]
---


### 1. **핵심 개념**

- **중복되는 하위 문제 (Overlapping Subproblems)**: 다이나믹 프로그래밍은 동일한 하위 문제를 반복해서 해결하는 경우에 적합해. 예를 들어, 피보나치 수열을 계산할 때 동일한 값이 여러 번 재계산될 수 있다.
- **최적 부분 구조 (Optimal Substructure)**: 문제의 최적 해결 방법이 그 하위 문제들의 최적 해결 방법으로부터 구성될 수 있을 때, 그 문제는 최적 부분 구조를 가진다고 할 수 있다. 다이나믹 프로그래밍은 이 특성을 이용해 문제를 단계적으로 해결한다.

#### 2. **해결 방법**

- **메모이제이션 (Memoization)**: 재귀적 접근에서 중복되는 계산을 방지하기 위해 이미 계산된 하위 문제의 결과를 저장해두고 필요할 때 다시 사용하는 방식이다. 일반적으로 재귀적 함수를 사용하고, 계산된 결과를 저장할 배열이나 해시맵을 사용한다.
- **타뷸레이션 (Tabulation)**: 하위 문제들을 모두 해결하고, 그 결과를 테이블(배열)에 채워가면서 문제를 해결하는 방법이다. 일반적으로 반복문을 사용해 하위 문제부터 차례로 해결한다.

#### 3. **다이나믹 프로그래밍 문제 풀이 단계**

1. **문제 정의**: 문제를 작은 하위 문제로 나눌 수 있는지, 그리고 중복되는 하위 문제가 존재하는지 확인한다.
2. **상태 정의**: 문제를 해결하기 위해 필요한 상태를 정의하고, 이 상태를 표현할 변수를 정의한다.
3. **점화식 도출**: 현재 상태를 이전 상태들로 표현할 수 있는 수식을 도출한다. 이 수식은 문제를 해결하는 핵심 요소가 된다.
4. **초기값 설정**: 점화식 계산에 필요한 초기 조건을 설정한다.
5. **최적해 도출**: 정의된 상태와 점화식을 이용해 최종 문제의 해를 구한다.

#### 4. **다양한 다이나믹 프로그래밍 문제**


#### [1. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)

- **문제 개요**: 주어진 계단 수를 1계단 또는 2계단씩 오를 수 있을 때, 정상에 오르는 방법의 수를 계산하는 문제이다.
- **점화식**: `dp[i] = dp[i-1] + dp[i-2]`
- **초기값**: `dp[0] = 1`, `dp[1] = 1`
- **설명**: 피보나치 수열과 유사한 방식으로 문제를 해결할 수 있다. 각 계단까지의 경로 수는 그 이전 두 계단에서 오는 경로의 합이 된다.

#### [2. House Robber](https://leetcode.com/problems/house-robber/)

- **문제 개요**: 인접한 집을 털 수 없을 때, 주어진 집들에서 가장 많이 훔칠 수 있는 돈의 최대값을 구하는 문제이다.
- **점화식**: `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`
- **초기값**: `dp[0] = nums[0]`, `dp[1] = max(nums[0], nums[1])`
- **설명**: 현재 집을 털지 않는 경우와 털고 두 칸 떨어진 집의 값을 더하는 경우를 비교하여 최대값을 구한다.

#### [3. House Robber II](https://leetcode.com/problems/house-robber-ii/)

- **문제 개요**: 집들이 원형으로 배열된 상황에서, 첫 번째 집과 마지막 집이 인접하지 않도록 최대 돈을 훔치는 문제이다.
- **점화식**: `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`을 두 번 계산: 1) 첫 번째 집을 포함하지 않는 경우, 2) 마지막 집을 포함하지 않는 경우.
- **설명**: 원형 구조로 인해 첫 집과 마지막 집을 동시에 털 수 없으므로, 두 가지 경우를 나누어 계산한 후 최대값을 선택한다.

#### [4. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)

- **문제 개요**: 주어진 문자열에서 가장 긴 회문(앞뒤가 같은 문자열) 부분 문자열을 찾는 문제이다.
- **점화식**: `dp[i][j] = (s.charAt(i) == s.charAt(j)) && (j-i <= 2 || dp[i+1][j-1])`
- **초기값**: 모든 단일 문자와 인접한 두 문자들을 초기값으로 설정한다.
- **설명**: 각 부분 문자열이 회문인지 여부를 점진적으로 확인하면서 가장 긴 회문을 찾는다.

#### [5. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)

- **문제 개요**: 주어진 문자열에서 회문인 부분 문자열의 개수를 구하는 문제이다.
- **점화식**: `dp[i][j] = (s.charAt(i) == s.charAt(j)) && (j-i <= 2 || dp[i+1][j-1])`
- **설명**: Longest Palindromic Substring 문제와 유사한 방식으로 각 부분 문자열이 회문인지 확인하면서 카운트한다.

#### [6. Decode Ways](https://leetcode.com/problems/decode-ways/)

- **문제 개요**: 숫자로 이루어진 문자열을 특정 알파벳으로 디코딩할 수 있는 방법의 수를 계산하는 문제이다. (예: "12"는 "AB" 또는 "L"로 해석 가능)
- **점화식**: `dp[i] = dp[i-1] + dp[i-2]` (해석 가능한 경우를 고려)
- **초기값**: `dp[0] = 1`, `dp[1] = 1` (첫 문자가 유효한 경우)
- **설명**: 각 숫자가 하나 또는 두 개로 해석될 수 있는지에 따라 해석 방법의 수를 계산한다.

#### [7. Coin Change](https://leetcode.com/problems/coin-change/)

- **문제 개요**: 주어진 동전 종류로 특정 금액을 만들기 위해 필요한 최소 동전 개수를 구하는 문제이다.
- **점화식**: `dp[i] = min(dp[i], dp[i - coin] + 1)` (모든 동전을 고려하여 최소값 갱신)
- **초기값**: `dp[0] = 0`, 나머지는 무한대로 초기화한다.
- **설명**: 모든 금액을 만들 수 있는 최소 동전 개수를 계산하여 문제를 해결한다.

#### [8. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)

- **문제 개요**: 주어진 배열에서 연속된 부분 배열의 곱이 최대가 되는 값을 구하는 문제이다.
- **점화식**: `dp_max[i] = max(nums[i], nums[i] * dp_max[i-1], nums[i] * dp_min[i-1])`
- **초기값**: `dp_max[0] = dp_min[0] = nums[0]`
- **설명**: 양수와 음수의 곱셈을 고려하여 현재 최대와 최소 값을 동시에 관리하며 문제를 해결한다.

#### [9. Word Break](https://leetcode.com/problems/word-break/)

- **문제 개요**: 주어진 단어 집합으로 특정 문자열을 구성할 수 있는지 확인하는 문제이다.
- **점화식**: `dp[i] = dp[j] && wordDict.contains(s.substring(j, i))` (0 ≤ j < i)
- **초기값**: `dp[0] = true`
- **설명**: 주어진 문자열을 나누어 단어 집합에 있는 단어들로 구성할 수 있는지 여부를 점검한다.

#### [10. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)

- **문제 개요**: 주어진 배열에서 가장 긴 증가하는 부분 수열의 길이를 구하는 문제이다.
- **점화식**: `dp[i] = max(dp[i], dp[j] + 1)` (0 ≤ j < i and nums[j] < nums[i])
- **초기값**: 각 `dp[i]`를 1로 초기화한다.
- **설명**: 각 요소를 기준으로 이전 요소들과 비교하여 증가하는 수열의 최대 길이를 갱신한다.

#### 5. **기타 대표적인 다이나믹 프로그래밍 문제들**


#### 피보나치 수열 (Fibonacci Sequence)

- **문제 개요**: 피보나치 수열의 n번째 항을 구하는 문제이다.
- **점화식**: `F(n) = F(n-1) + F(n-2)`
- **초기값**: `F(0) = 0`, `F(1) = 1`
- **설명**: 메모이제이션이나 타뷸레이션 방법을 사용하여 중복 계산을 방지하며 해결할 수 있다.

#### 최장 공통 부분 수열 (Longest Common Subsequence, LCS)

- **문제 개요**: 두 문자열에서 공통된 부분 수열 중 가장 긴 것을 찾는 문제이다.
- **점화식**: `LCS[i][j] = LCS[i-1][j-1] + 1` (if `str1[i] == str2[j]`),
`LCS[i][j] = max(LCS[i-1][j], LCS[i][j-1])` (otherwise)
- **초기값**: `LCS[0][j] = 0`, `LCS[i][0] = 0`
- **설명**: 2차원 배열을 사용하여 각 부분 문자열 간의 최대 공통 부분 수열을 찾아낸다.

#### 배낭 문제 (Knapsack Problem)

- **문제 개요**: 일정한 무게 제한 내에서 물건을 선택하여 최대 가치를 얻는 문제이다.
- **점화식**: `K[i][w] = max(K[i-1][w], K[i-1][w-weight[i]] + value[i])`
- **초기값**: `K[0][w] = 0`, `K[i][0] = 0`
- **설명**: 2차원 배열을 사용하여 물건들의 최대 가치를 계산한다.

#### 6. **다이나믹 프로그래밍의 장단점**

- **장점**:
	- 재귀적 접근에서 발생하는 중복 계산을 방지하여 시간 효율성을 높인다.
	- 복잡한 문제를 작은 문제로 나누어 체계적으로 해결할 수 있다.
- **단점**:
	- 메모이제이션을 사용할 때 추가적인 메모리 공간이 필요할 수 있다.
	- 문제에 따라 DP 테이블이 커지면 공간 복잡도가 증가할 수 있다.
