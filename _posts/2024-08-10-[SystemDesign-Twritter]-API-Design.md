---
layout: post
date: 2024-08-10
title: "[SystemDesign-Twritter] API Design"
tags: [SystemDesign, Architecture, Twitter, ]
categories: [SystemDesign, Problems, Twitter, ]
---


데이터베이스 샤딩 시 어떤 기준으로 샤딩을 할 것인지? 


user_id로 샤딩을 했을 경우 한 서버에 사용자의 트윗 정보가 모두 저장되어있기 때문에 조회하기 편하다. 하지만 몇가지의 문제가 있다. 

- 특정 사용자가 매우 인기를 끌게 되면, 해당 사용자의 데이터를 보유한 서버에 많은 요청이 몰려 과부하가 발생한다.
- 일부 사용자는 다른 사용자에 비해 훨씬 더 많은 트윗이나 팔로워를 갖게 되어 서버 간 데이터가 고르게 분배되지 않는다. 이런경우 샤드을 효율적으로 쓸 수가 없다.
- 특성 샤드의 공간을 늘려야 할 경우 재배치를 해야하기 때문에 리소스가 많이 발생한다.

특정 사용자의 정보를 캐시에 저장하는 것도 하나의 방법이지만 여전히 샤딩을 효율적으로 사용하는 방법이 아니다. user_id 대신 사용할 수 있는 방법은 어떤게 있을까?


트윗 ID를 시간 + auto-increment 방식으로 구현 시 시간 기반으로 샤딩이 생성되기 때문에 여러 샤드에 고르게 분배가 될 수가 있다. 시간과 auto-increment를 함께 사용할 경우 트윗이 생성된 순서대로 정렬되기 때문에 트위터와 같은 타임라인을 생성할때 효율적이다.  이전에 포스팅했던 인스타그램과 거의 유사한 방식이다. 인스타그램은 Shard ID도 함께 추가했다는게 다른 점이다.


#### **트위터에서의 샤딩 구현 방안:**

1. **트윗 ID 설계**:
	- 트윗 ID는 **시간(Time) + auto-increment** 방식으로 구성한다.
	- 예를 들어, 에포크 시간(1970년 1월 1일 기준 초 단위)과 auto-increment 값을 결합하여 트윗 ID를 생성한다.
	- 각 트윗 ID는 고유하며, 생성된 시점에 따라 자연스럽게 정렬된다.
2. **샤드 선택 알고리즘**:
	- 트윗이 생성될 때, 트윗 ID에 기반하여 샤드를 선택하는데 시간에 따른 데이터 분산을 위해 `MOD(트윗 ID % 샤드 수)`와 같은 방법을 사용하여 트윗이 저장될 샤드를 결정할 수 있다.
	- 이를 통해 시간에 따라 트윗이 고르게 샤드에 분산되며, 특정 샤드에 데이터가 몰리지 않도록 한다.
3. **타임라인 생성**:
	- 사용자가 타임라인을 조회할 때, 최근 생성된 트윗을 시간 순서대로 빠르게 조회할 수 있도록 샤드에서 데이터를 병렬로 조회한다.
	- 각 샤드에서 조회된 데이터를 애플리케이션 서버에서 병합하고, 최종 타임라인을 구성하여 사용자에게 제공한다.
4. **캐싱 전략**:
	- 인기 있는 트윗이나 특정 시간대에 생성된 트윗은 캐싱하여, 반복 조회 시 데이터베이스에 부담을 줄이고 응답 시간을 단축할 수 있다.

![0](/assets/img/2024-08-10-[SystemDesign-Twritter]-API-Design.md/0.png)

