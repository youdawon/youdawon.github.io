---
layout: post
date: 2024-08-18
title: "[SystemDesign-Facebook Newsfeed] 사용자별 뉴스피드 데이터 저장 방식"
tags: [System Design, Architecture, Facebook Newsfeed, ]
categories: [System Design, Problems, Facebook Newsfeed, ]
---


### **1. 기본 개념**


피드 데이터는 사용자가 팔로우하는 사용자나 엔터티의 게시물로 구성된다. 이 데이터는 효율적으로 저장되고, 사용자가 요청할 때 빠르게 제공될 수 있어야 한다. 피드 데이터 저장 방법은 성능 최적화와 데이터 일관성을 유지하는 데 중요한 역할을 한다.


#### **2. 주요 저장 방법**


#### **a. 실시간 생성 vs. 오프라인 생성**

- **실시간 생성:**
	- 사용자가 피드를 요청할 때마다 즉시 생성한다.
	- 사용자가 팔로우하는 모든 사용자와 엔터티의 최신 게시물을 실시간으로 쿼리하여 피드를 생성한다.
	- **장점:** 항상 최신의 피드를 제공할 수 있음.
	- **단점:** 많은 사용자를 팔로우하는 경우 성능 저하가 발생할 수 있으며, 실시간 생성으로 인해 서버 부하가 큼.
- **오프라인 생성:**
	- 사용자의 피드를 정기적으로 생성하여 미리 저장해 둔다.
	- 특정 시간 간격으로 사용자 피드를 생성하고, 이를 메모리 또는 데이터베이스에 저장한다.
	- **장점:** 서버 부하를 줄이고, 사용자가 요청할 때 빠르게 피드를 제공할 수 있음.
	- **단점:** 실시간성이 떨어질 수 있으나, 일정 주기로 갱신하여 보완 가능.

#### **b. 캐시 사용**



{% raw %}
```java
// 사용자별 피드 정보를 저장하는 구조체
Struct {
    LinkedHashMap<FeedItemID, FeedItem> feedItems; // 사용자 피드 항목 저장
    DateTime lastGenerated; // 마지막으로 피드가 생성된 시간
}

// 전체 사용자 피드를 저장하는 LinkedHashMap
LinkedHashMap<UserID, Struct> userFeeds = new LinkedHashMap<>();
```
{% endraw %}


- **캐시 저장:**
	- 최근 생성된 피드 데이터를 메모리에 캐시하여 빠르게 접근할 수 있도록 한다.
	- LRU(Least Recently Used) 또는 LFU(Least Frequently Used)와 같은 캐시 관리 정책을 적용하여 자주 사용되지 않는 데이터를 자동으로 제거한다.
	- **장점:** 빠른 데이터 접근을 통해 성능을 크게 향상시킨다.
	- **단점:** 메모리 용량에 제한이 있으며, 캐시가 만료되거나 부족할 경우 추가적인 쿼리가 필요하다.
- **캐시와 데이터베이스 조합:**
	- 최근 500개의 피드 항목을 메모리에 저장하고, 이보다 오래된 데이터는 데이터베이스에 저장하여 관리한다.
	- **장점:** 자주 조회되는 데이터는 메모리에서 빠르게 제공하고, 오래된 데이터는 데이터베이스에서 관리하여 효율성을 극대화한다.

#### **c. 피드 항목 저장 구조**

- **LinkedHashMap을 활용한 저장:**
	- `UserID`를 키로 하고, `LinkedHashMap`을 이용해 사용자별로 피드 항목을 저장한다.
	- 각 피드 항목은 `FeedItemID`를 기준으로 정렬되어 있으며, 사용자는 마지막으로 본 항목 이후의 피드를 빠르게 조회할 수 있다.
	- **장점:** 데이터의 삽입 순서 또는 접근 순서를 유지하며 관리 가능하다.
- **LFU를 적용한 캐시 관리:**
	- 사용 빈도에 따라 피드 데이터를 관리하여, 가장 자주 사용되지 않는 항목을 캐시에서 제거한다.
	- **장점:** 메모리를 효율적으로 사용하며, 자주 사용되는 데이터는 캐시에 남겨둬 성능을 향상시킨다.

#### d. **두 가지 필드를 함께 사용하는 이유**

- **`FeedItemID`** **사용**
	- **목적**: 사용자가 마지막으로 본 피드 항목의 ID를 기반으로 이후의 피드를 빠르게 조회하기 위함이다.
	- **장점**: 사용자가 중단한 지점에서 피드를 이어볼 수 있어. 특히, 스크롤을 통해 여러 페이지를 탐색할 때 유용하다.
	- **사용 상황**: 사용자가 뉴스피드를 다시 열었을 때, 마지막으로 본 항목 이후의 게시물을 가져오도록 한다.
	- **목적**: 사용자가 마지막으로 피드를 생성한 시점을 기준으로 그 이후에 생성된 새로운 피드 항목을 빠르게 조회하는 것을 목표로 한다.
	- **사용 상황**: 사용자가 피드를 새로고침하거나, 정기적으로 생성된 피드를 가져올 때, `lastGenerated` 시점 이후의 새로운 게시물을 빠르게 가져올 수 있다.
1. **`lastGenerated`** **사용**
	- **목적**: 사용자가 마지막으로 피드를 생성한 시점을 기준으로 새로운 피드 항목을 조회하기 위함이다.
	- **장점**: 특정 시간 이후에 생성된 게시물만을 빠르게 필터링하여 효율적인 피드 업데이트가 가능하다.
	- **사용 상황**: 사용자가 피드를 새로 고침하거나, 피드가 정기적으로 업데이트될 때, 새로운 게시물만을 가져오도록 설계됐다.
	- **목적**: 사용자가 뉴스피드를 스크롤하면서 특정 지점(마지막으로 본 피드 항목) 이후의 피드를 가져오는 것을 목표로 한다.
	- **사용 상황**: 사용자가 뉴스피드를 중단했다가 다시 돌아왔을 때, 정확히 그 지점에서부터 이어서 피드를 볼 수 있도록 한다.

#### **3. 최적화 전략**

- **하이브리드 접근:** 실시간 생성과 오프라인 생성을 조합하여, 성능과 최신성을 모두 확보하는 방식.
- **LRU/LFU 캐시 관리:** 자주 사용되지 않는 데이터를 자동으로 제거해 메모리 사용량을 최적화.
- **사용자 행동 기반 생성:** 사용자의 로그인 패턴에 따라 뉴스피드를 미리 생성해 둘 수 있다.

#### **4. 데이터 저장 방법의 유연성**

- **사용자 요구에 따른 조정:** 사용자의 행동 패턴, 장치 유형(모바일/데스크탑)에 따라 저장 방식과 캐시 크기를 조정할 수 있다.
- **피드 항목의 조각화:** 페이지 단위로 피드 항목을 분리해 관리하여, 사용자가 특정 범위의 피드만 요청할 수 있다.
