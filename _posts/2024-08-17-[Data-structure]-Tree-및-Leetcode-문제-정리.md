---
layout: post
date: 2024-08-17
title: "[Data structure] Tree 및 Leetcode 문제 정리"
tags: [DataStructure, ]
categories: [DataStructure, Tree, ]
---


### 1. 기본 개념

- **트리(Tree)**: 계층적 데이터 구조로, 하나의 루트 노드에서 시작해 자식 노드로 연결되는 구조를 가짐.
- **노드(Node)**: 트리의 각 요소로, 데이터와 자식 노드를 가리키는 포인터(혹은 참조)를 포함.
- **루트 노드(Root Node)**: 트리의 최상위 노드.
- **리프 노드(Leaf Node)**: 자식 노드가 없는 노드.
- **부모 노드(Parent Node)**와 **자식 노드(Child Node)**: 특정 노드가 다른 노드를 가리킬 때, 가리키는 노드를 자식 노드, 가리키는 노드를 부모 노드라 함.
- **서브트리(Subtree)**: 트리의 부분 트리, 특정 노드와 그 하위 노드들이 서브트리를 이룸.
- **높이(Height)**: 노드에서 리프까지의 가장 긴 경로의 길이.
- **깊이(Depth)**: 루트에서 특정 노드까지의 경로의 길이.

#### 2. 트리의 종류


#### 2.1 **이진 트리 (Binary Tree)**

- **개념**: 각 노드가 최대 두 개의 자식을 가지는 트리. 이진 트리는 다양한 응용 분야에서 사용되며, 트리 순회, 노드 삽입 및 삭제 등의 기본 연산을 연습할 때 자주 사용됨.
- **예시 그림**:


{% raw %}
```markdown
    1
   / \
  2   3
 / \   \
4   5   6
```
{% endraw %}



#### 2.2 **완전 이진 트리 (Complete Binary Tree)**

- **개념**: 마지막 레벨을 제외한 모든 레벨이 완전히 채워진 이진 트리. 이진 힙 구조에서 자주 사용되며, 노드가 가능한 왼쪽에서부터 채워짐.
- **예시 그림**:


{% raw %}
```markdown
      1
    /   \
   2     3
  / \   /
 4   5 6
```
{% endraw %}



#### 2.3 **이진 탐색 트리 (Binary Search Tree, BST)**

- **개념**: 왼쪽 자식 노드의 값이 부모보다 작고, 오른쪽 자식 노드의 값이 부모보다 큰 이진 트리. BST는 검색, 삽입, 삭제 연산에서 평균 O(log n) 시간 복잡도를 제공함.
- **예시 그림**:


{% raw %}
```markdown
    4
   / \
  2   6
 / \ / \
1  3 5  7
```
{% endraw %}



#### 2.4 **균형 이진 트리 (Balanced Binary Tree)**

- **개념**: 모든 서브트리의 높이 차이가 1 이하인 이진 트리. 균형 이진 트리는 트리의 깊이를 최소화하여 연산의 효율성을 높임.
- **예시 그림**:


{% raw %}
```markdown
      5
    /   \
   3     8
  / \   / \
 2   4 6   9
```
{% endraw %}



#### 2.5 **레드-블랙 트리 (Red-Black Tree)**

- **개념**: 자가 균형 이진 탐색 트리로, 삽입과 삭제 시 트리의 균형을 유지하는 트리. 노드는 색상(Red 또는 Black)을 가지며, 특정 규칙을 따라 균형을 유지함. 최악의 경우에도 O(log n) 시간 복잡도를 보장함.
- **예시 그림**:
(노드 색상: R = Red, B = Black)


{% raw %}
```markdown
markdown코드 복사
      7B
     /  \
   3R    10B
  / \    / \
 1B  5B 8R  12B
```
{% endraw %}



#### 2.6 **트라이 (Trie)**

- **개념**: 문자열 검색을 위한 특수한 트리 구조. 각 노드가 문자열의 한 문자를 나타내며, 단어의 접두사를 공유하는 문자열들을 효율적으로 저장하고 탐색할 수 있음.
- **예시 그림**:
(단어: "cat", "car", "dog")


{% raw %}
```text
        (root)
        /  |  \
       c   d   a
      /    |    \
     a     o     t
    /      |     |
   t(R)    g(R)  r(R)
    \      |
     r(R)  s(R)
```
{% endraw %}



(R = 단어의 끝을 표시)


#### 2.7 **세그먼트 트리 (Segment Tree)**

- **개념**: 배열의 특정 구간에 대한 쿼리(합, 최소/최대값)를 효율적으로 처리하기 위한 트리 구조. 구간 합 계산, 구간 최소값 및 최대값을 구하는 문제에서 유용하게 사용됨.
- **예시 그림**:
(배열: `[2, 1, 5, 3]`에 대한 세그먼트 트리)


{% raw %}
```markdown
          11
         /  \
       3      8
      / \    / \
     2   1  5   3
```
{% endraw %}



#### 2.8 **이진 힙 (Binary Heap)**

- **개념**: 최대 또는 최소 값을 효율적으로 추출하기 위한 완전 이진 트리. 최대 힙(Max-Heap)과 최소 힙(Min-Heap)으로 나뉘며, 우선순위 큐의 기본 자료구조로 사용됨.
- **예시 그림**:
(최대 힙의 예시)


{% raw %}
```markdown
      10
     /  \
    9    8
   / \  / \
  7  6 5   4
```
{% endraw %}



#### 3. 트리의 주요 연산 및 알고리즘

- **트리 순회(Tree Traversal)**:
	- **전위 순회(Preorder Traversal)**: 루트 -> 왼쪽 서브트리 -> 오른쪽 서브트리.
	- **중위 순회(Inorder Traversal)**: 왼쪽 서브트리 -> 루트 -> 오른쪽 서브트리.
	- **후위 순회(Postorder Traversal)**: 왼쪽 서브트리 -> 오른쪽 서브트리 -> 루트.
	- **레벨 순서 순회(Level-Order Traversal)**: 루트부터 레벨별로 순차 탐색 (BFS).
- **삽입(Insertion)**: 새로운 노드를 트리에 추가하는 과정. 이진 탐색 트리에서는 새로운 노드를 적절한 위치에 삽입하여 트리의 속성을 유지함.
- **삭제(Deletion)**: 트리에서 노드를 제거하는 과정. 이진 탐색 트리에서는 삭제하려는 노드의 자식에 따라 다르게 처리함 (리프 노드, 자식이 하나인 노드, 자식이 두 개인 노드).
- **탐색(Search)**: 트리에서 특정 값을 찾는 과정. 이진 탐색 트리에서는 O(log n) 시간 복잡도를 가짐.

#### 4. 트리와 관련된 중요한 문제 유형

- **이진 트리의 직경 (Diameter of a Binary Tree)**: 이진 트리에서 두 노드 간의 최대 거리를 찾는 문제.
- **Lowest Common Ancestor (LCA)**: 두 노드의 공통된 조상을 찾는 문제.
- **이진 탐색 트리의 검증 (Validate BST)**: 주어진 트리가 이진 탐색 트리인지 확인하는 문제.
- **경로 합 (Path Sum)**: 루트에서 리프까지의 경로 중 특정 합을 가지는 경로가 있는지 확인하는 문제.
- **Serialize and Deserialize Binary Tree**: 트리 구조를 직렬화하고 역직렬화하는 문제.
- **Balanced Binary Tree**: 주어진 이진 트리가 균형 이진 트리인지 확인하는 문제.

#### 5. 심화 주제

- **Segment Tree**: 구간 합, 최소/최대값 쿼리 및 업데이트를 효율적으로 처리하는 트리. 주로 범위 쿼리 문제에서 사용됨.
- **Trie**: 문자열 검색, 자동 완성, 사전 기능 구현 등에 사용됨. 문자열 관련 문제에서 자주 등장.
- **Red-Black Tree**: 자가 균형 이진 탐색 트리로, 균형을 유지하여 최악의 경우에도 O(log n) 성능을 보장함.
- **Fenwick Tree (Binary Indexed Tree, BIT)**: 주로 구간 합을 빠르게 계산하기 위해 사용되는 자료구조.

#### 6. 트리 관련 리트코드 문제

- Binary Tree Inorder Traversal
- [Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
- [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/)
- Serialize and Deserialize Binary Tree
- Validate Binary Search Tree

#### 7. **면접 팁**

- **기본기를 다져라**: 트리의 기본 개념과 각종 트리의 특징을 확실하게 이해하라.
- **손코딩 연습**: 트리 순회, 삽입, 삭제, 탐색 등의 기본적인 알고리즘을 손코딩으로 연습하라.
- **실전 문제 풀기**: 리트코드, 코드포스 등에서 트리 관련 문제를 많이 풀어보라.
- **시간 복잡도 분석**: 트리 관련 알고리즘의 시간 복잡도를 정확히 이해하고 설명할 수 있도록 하라.
- **경계 조건**: 트리 문제에서는 종종 경계 조건(예: 트리가 비었을 때, 단일 노드 트리 등)이 중요하다. 이를 잘 고려하도록 연습하라.
